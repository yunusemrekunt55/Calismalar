# -*- coding: utf-8 -*-
"""ResNET.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19i0dkEL40t7N5I2E1f2U--e6MXEuFBlA
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras import layers, models, datasets, utils

def residual_block(x, filters, kernel_size=3, stride=1):
    res = x
    x = layers.Conv2D(filters, kernel_size, strides=stride, padding="same")(x)
    x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)
    x = layers.Conv2D(filters, kernel_size, padding="same")(x)
    x = layers.BatchNormalization()(x)
    if stride != 1:
      res = layers.Conv2D(filters, 1, strides=stride, padding="same")(res)

    x = layers.add([x, res])
    x = layers.ReLU()(x)
    return x

def build_resnet(input_shape, num_classes):
    inputs = layers.Input(shape=input_shape)
    x = layers.Conv2D(64, 7, strides=2, padding="same")(inputs)
    x = layers.BatchNormalization()(x)
    x = layers.ReLU()(x)
    x = layers.MaxPooling2D(3, strides=2, padding="same")(x)

    x = residual_block(x, 64)
    x = residual_block(x, 64)
    x = residual_block(x, 64)

    x = residual_block(x, 128, stride=2)
    x = residual_block(x, 128)
    x = residual_block(x, 128)

    x = layers.GlobalAveragePooling2D()(x)
    x = layers.Dense(num_classes, activation='softmax')(x)

    model = models.Model(inputs, x)
    return model

(x_train, y_train), (x_test, y_test) = datasets.mnist.load_data()
x_train = np.expand_dims(x_train, axis=-1).astype("float32") / 255.0
x_test = np.expand_dims(x_test, axis=-1).astype("float32") / 255.0
y_train = utils.to_categorical(y_train, 10)
y_test = utils.to_categorical(y_test, 10)

# Build and compile the model
model = build_resnet(input_shape=(28, 28, 1), num_classes=10)
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

model.fit(x_train, y_train, batch_size=64, epochs=10, validation_split=0.1)

test_loss, test_acc = model.evaluate(x_test, y_test)
print(f"Test accuracy: {test_acc}")

model.fit(x_train_rgb, y_train, validation_data=(x_test_rgb, y_test), epochs=10, batch_size=32)

import matplotlib.pyplot as plt

# Veriler
epochs = list(range(1, 11))
loss = [0.1075, 0.0452, 0.0366, 0.0297, 0.0253, 0.0227, 0.0184, 0.0173, 0.0154, 0.0131]
accuracy = [0.9668, 0.9859, 0.9883, 0.9906, 0.9922, 0.9926, 0.9941, 0.9941, 0.9954, 0.9959]
val_loss = [0.1237, 0.0437, 0.0361, 0.0386, 0.0375, 0.0359, 0.0273, 0.0380, 0.0278, 0.0283]
val_accuracy = [0.9610, 0.9860, 0.9887, 0.9890, 0.9897, 0.9893, 0.9923, 0.9903, 0.9930, 0.9928]

# Grafiklerin oluşturulması
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Kayıp grafiği
ax1.plot(epochs, loss, 'm', label='Eğitim Kaybı')
ax1.plot(epochs, val_loss, 'r', label='Doğrulama Kaybı')
ax1.set_title('Eğitim  Kaybı')
ax1.set_xlabel('eps')
ax1.set_ylabel('Kayıp')
ax1.legend()

# Doğruluk grafiği
ax2.plot(epochs, accuracy, 'b', label='Eğitim Doğruluğu')
ax2.plot(epochs, val_accuracy, 'r', label='Doğrulama Doğruluğu')
ax2.set_title('Eğitim Doğruluğu')
ax2.set_xlabel('eps')
ax2.set_ylabel('acc')
ax2.legend()

plt.show()

