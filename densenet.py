# -*- coding: utf-8 -*-
"""denseNET.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14NnogtEftzlXEJoQdr-TpLYe-sbsdv6B
"""

import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import to_categorical

def dense_block(x, blocks, name):
    for i in range(blocks):
        x = conv_block(x, 32, name=name + '_block' + str(i + 1))
    return x

def transition_block(x, reduction, name):
    x = layers.BatchNormalization(axis=3, epsilon=1.001e-5, name=name + '_bn')(x)
    x = layers.Activation('relu', name=name + '_relu')(x)
    x = layers.Conv2D(int(tf.keras.backend.int_shape(x)[3] * reduction), 1, use_bias=False, name=name + '_conv')(x)
    # Check if spatial dimensions are greater than 1 before pooling
    if tf.keras.backend.int_shape(x)[1] > 1:
        x = layers.AveragePooling2D(2, strides=2, name=name + '_pool')(x)
    return x



def DenseNet(input_shape, classes):
    img_input = layers.Input(shape=input_shape)
    x = layers.ZeroPadding2D(padding=((3, 3), (3, 3)))(img_input)
    x = layers.Conv2D(64, 7, strides=2, use_bias=False, name='conv1/conv')(x)
    x = layers.BatchNormalization(axis=3, epsilon=1.001e-5, name='conv1/bn')(x)
    x = layers.Activation('relu', name='conv1/relu')(x)
    x = layers.ZeroPadding2D(padding=((1, 1), (1, 1)))(x)
    x = layers.MaxPooling2D(3, strides=2, name='pool1')(x)

    x = dense_block(x, blocks=6, name='conv2')
    x = transition_block(x, 0.5, name='pool2')
    x = dense_block(x, blocks=12, name='conv3')
    x = transition_block(x, 0.5, name='pool3')
    x = dense_block(x, blocks=24, name='conv4')
    x = transition_block(x, 0.5, name='pool4')
    x = dense_block(x, blocks=16, name='conv5')

    x = layers.BatchNormalization(axis=3, epsilon=1.001e-5, name='bn')(x)
    x = layers.GlobalAveragePooling2D(name='avg_pool')(x)
    x = layers.Dense(classes, activation='softmax', name='fc1000')(x)

    model = models.Model(img_input, x, name='densenet')
    return model

(input_shape, num_classes) = ((28, 28, 1), 10)
model = DenseNet(input_shape, num_classes)
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

train_images = train_images.reshape((60000, 28, 28, 1)).astype('float32') / 255
test_images = test_images.reshape((10000, 28, 28, 1)).astype('float32') / 255

train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

model.fit(train_images, train_labels, epochs=10, batch_size=32, validation_split=0.2)

test_loss, test_acc = model.evaluate(test_images, test_labels)
print('Test accuracy:', test_acc)

import matplotlib.pyplot as plt
epochs = list(range(1, 11))
loss = [0.2141, 0.1083, 0.0879, 0.0868, 0.0576, 0.0604, 0.0397, 0.0390, 0.0296, 0.0446]
accuracy = [0.9376, 0.9705, 0.9765, 0.9768, 0.9839, 0.9833, 0.9888, 0.9887, 0.9908, 0.9879]
val_loss = [0.3190, 0.0925, 0.0979, 0.0958, 0.0986, 0.0470, 0.0297, 0.0335, 0.0369, 0.0404]
val_accuracy = [0.9429, 0.9727, 0.9753, 0.9712, 0.9721, 0.9867, 0.9915, 0.9896, 0.9895, 0.9891]

# Grafiklerin oluşturulması
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# Kayıp grafiği
ax1.plot(epochs, loss, 'b', label='Eğitim Kaybı')
ax1.plot(epochs, val_loss, 'r', label='Doğrulama Kaybı')
ax1.set_title('Eğitim ve Doğrulama Kaybı')
ax1.set_xlabel('Dönemler')
ax1.set_ylabel('Kayıp')
ax1.legend()

# Doğruluk grafiği
ax2.plot(epochs, accuracy, 'b', label='Eğitim Doğruluğu')
ax2.plot(epochs, val_accuracy, 'r', label='Doğrulama Doğruluğu')
ax2.set_title('Eğitim ve Doğrulama Doğruluğu')
ax2.set_xlabel('Dönemler')
ax2.set_ylabel('Doğruluk')
ax2.legend()

plt.show()

